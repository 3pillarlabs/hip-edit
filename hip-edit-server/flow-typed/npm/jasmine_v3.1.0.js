// flow-typed signature: d17617d38d4e7e91f95282f7abfc30cc
// flow-typed version: <<STUB>>/jasmine_v3.1.0/flow_v0.89.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'jasmine'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

// @flow

type doneT = {
  (): void,
  fail: () => void
};

type doneCb = doneT => mixed;
type asyncCb = empty => Promise<mixed>;
type doneOrAsyncCb = doneCb & asyncCb;

declare function describe(name: string, fn?: () => void): void;
declare function fdescribe(name: string, fn?: () => void): void;
declare function xdescribe(name: string, fn?: () => void): void;
declare function beforeEach(fn: doneOrAsyncCb): void;
declare function beforeEachAsync(fn: asyncCb): void;
declare function afterEach(fn: doneOrAsyncCb): void;
declare function it(name: string, fn?: doneOrAsyncCb): void;
declare function itAsync(name: string, fn?: asyncCb): void;
declare function fit(name: string, fn?: doneOrAsyncCb): void;
declare function xit(name: string, fn?: doneOrAsyncCb): void;
declare function expect(expected: mixed): expectation;
declare function spyOn(fn: any, name: string): spy;
declare function fail(error: string | Error): void;

type expectation = {
  not: expectation,
  toEqual: (actual: mixed) => void,
  toBe: (actual: mixed) => void,
  toBeNull: () => void,
  toHaveBeenCalledOnceWith: (...rest: mixed[]) => void,
  toHaveBeenCalledTwiceWith: (...rest: mixed[]) => void,
  toHaveBeenCalledNTimesWith: (times: number, ...rest: mixed[]) => void,
  toHaveBeenCalledWith: (...rest: mixed[]) => void,
  toHaveBeenCalled: () => void,
  toHaveClass: (expected: string) => void,
  toHaveBeenCalledOnce: () => void,
  toThrow: (err: Error | Class<Error>) => void,
  toThrowError: (err: Error | Class<Error>, msg: string) => void,
  toBeTruthy(): void,
  toBeFalsy(): void
};

declare var jasmine: Jasmine;
declare class Jasmine {
  any(t: any): any,
  clock(): {
    install: () => void,
    uninstall: () => void,
    tick: (ms: number) => void
  },
  createSpy(name: string): spy,
  createSpyObj(name: any, methods: [string] | Object): any
}

type spy = {
  (...rest: any[]): any,
  and: {
    returnValue: (val: mixed) => spy,
    callFake: (fn: (...rest: mixed[]) => any) => spy,
    callThrough: () => spy,
    stub: () => void
  },
  calls: {
    first: () => any
  }
};

export type spyT = spy;
